As part of the QuTiP 3.2 release significant changes have been made to the
internal workings of the qutip.control (qtrl) modules. 
Originally developed as a standalone library these were merged
into the qutip project in 3.1, and so integration with the rest of the
qutip library is on-going. Hopefully this release is a major step forward
in this regard with the (optional) use of Qobj throughout qtrl now, and
also use of some qutip functions for processing sparse matrices.

The additional functionality is an implementation of the CRAB algorithm.
This is an alternative to the GRAPE algorithm, which allows for analytical
control functions, which means that experimental constraints can more
easily be added into optimisation. See tutorial notebook for full
information.

There have also been many cosmetic changes made to improve clarity, and
to make the code more Pythonic.
These include changing the names of some attributes, moving some attributes
to different objects, and replacing some get_ and set_ functions with 
property getters and setters. Attempts have been made to make the code
backwards compatible, but in some cases this may not have been successful.
Any code the only uses the pulseoptim functions, should continue to work
with all but a few deprecation warnings. However, customised sub-classes
may have issues, and are very likely to have many deprecation warnings.
Hence the motivation for this document, in particular what follows, 
which is a list of the name changes, so that users can easily see what
they will need want to change in their code.

Firstly, changes to support multiple control optimisation algorithms,
that were introduced to support the addition of CRAB.

Next, these are the changes to the core evolution calculation properties.
The internal state / quantum operator data type can now be either Qobj, 
ndarray, or any other data type that supports addition and multiplication
(through the dot method). This last option should be treated as experimental.
Original the plan was simply to swap from ndarray to Qobj, however for small
systems, Qobj had a lot of overhead in addition and multiplication.
Therefore, the attributes and functions that return these operators are now
preceded by an underscore, to indicate that the data type could change depending
on the configuration options. In most cases these functions were for internal
processing only anyway, and should have been 'private'. 

Accessors to the properties that could be useful outside of the library have
been added. These always return Qobj. If the internal operator data type is
not Qobj, then there could be signicant overhead in the conversion,
and so this should be avoided during pulse optimisation.
If custom sub-classes are developed that use Qobj properties and methods 
(e.g. partial trace), then it is very likely that it will be more efficient
to set the internal data type to Qobj.

The internal operator data will be chosen automatically based on the size
and sparsity of the dynamics generator. It can be forced by setting:
dynamics.oper_dtype = <type>
Note this can be done by passing:
dyn_params={'oper_dtype':<type>}
in any of the pulseoptim functions.

Function name changes
---------------------
Dynamics:-
get_num_ctrls: now property num_ctrls
get_owd_evo_target: now property: onto_evo_target
combine_dyn_gen: now _combine_dyn_gen, no longer returns a value
get_dyn_gen: now _get_phased_dyn_gen
get_ctrl_den_gen: now _get_phased_ctrl_dyn_gen

Property name changes
---------------------
Dynamics:-
evo_init2t -> evo_fwd
evo_t2end -> evo_onwd
evo_t2targ -> evo_onto




 





